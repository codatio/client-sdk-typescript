/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../../lib/schemas.js";
import { Decimal as Decimal$ } from "../../types/decimal.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * A source reference containing the `sourceType` object "Banking".
 */
export type ReportSourceReference = {
  /**
   * The data source type.
   */
  sourceType?: string | undefined;
};

export type Accounts = {
  /**
   * A source reference containing the `sourceType` object "Banking".
   */
  sourceRef?: ReportSourceReference | undefined;
  /**
   * Name of the banking data source, e.g. "Plaid".
   */
  platformName?: string | undefined;
  /**
   * The bank or other financial institution providing the account.
   */
  accountProvider?: string | undefined;
  /**
   * The name of the account according to the provider.
   */
  accountName?: string | undefined;
  /**
   * The type of banking account, e.g. credit or debit.
   */
  accountType?: string | undefined;
  /**
   * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
   *
   * @remarks
   *
   * ## Unknown currencies
   *
   * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction.
   *
   * There are only a very small number of edge cases where this currency code is returned by the Codat system.
   */
  currency?: string | undefined;
  /**
   * The balance of the bank account.
   */
  currentBalance?: Decimal$ | number | undefined;
};

/** @internal */
export const ReportSourceReference$inboundSchema: z.ZodType<
  ReportSourceReference,
  z.ZodTypeDef,
  unknown
> = z.object({
  sourceType: z.string().optional(),
});
/** @internal */
export type ReportSourceReference$Outbound = {
  sourceType?: string | undefined;
};

/** @internal */
export const ReportSourceReference$outboundSchema: z.ZodType<
  ReportSourceReference$Outbound,
  z.ZodTypeDef,
  ReportSourceReference
> = z.object({
  sourceType: z.string().optional(),
});

export function reportSourceReferenceToJSON(
  reportSourceReference: ReportSourceReference,
): string {
  return JSON.stringify(
    ReportSourceReference$outboundSchema.parse(reportSourceReference),
  );
}
export function reportSourceReferenceFromJSON(
  jsonString: string,
): SafeParseResult<ReportSourceReference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReportSourceReference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReportSourceReference' from JSON`,
  );
}

/** @internal */
export const Accounts$inboundSchema: z.ZodType<
  Accounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  sourceRef: z.lazy(() => ReportSourceReference$inboundSchema).optional(),
  platformName: z.string().optional(),
  accountProvider: z.string().optional(),
  accountName: z.string().optional(),
  accountType: z.string().optional(),
  currency: z.string().optional(),
  currentBalance: z.number().transform(v => new Decimal$(v)).optional(),
});
/** @internal */
export type Accounts$Outbound = {
  sourceRef?: ReportSourceReference$Outbound | undefined;
  platformName?: string | undefined;
  accountProvider?: string | undefined;
  accountName?: string | undefined;
  accountType?: string | undefined;
  currency?: string | undefined;
  currentBalance?: number | undefined;
};

/** @internal */
export const Accounts$outboundSchema: z.ZodType<
  Accounts$Outbound,
  z.ZodTypeDef,
  Accounts
> = z.object({
  sourceRef: z.lazy(() => ReportSourceReference$outboundSchema).optional(),
  platformName: z.string().optional(),
  accountProvider: z.string().optional(),
  accountName: z.string().optional(),
  accountType: z.string().optional(),
  currency: z.string().optional(),
  currentBalance: z.union([z.instanceof(Decimal$), z.number()]).transform(v =>
    typeof v === "number" ? v : v.toNumber()
  ).optional(),
});

export function accountsToJSON(accounts: Accounts): string {
  return JSON.stringify(Accounts$outboundSchema.parse(accounts));
}
export function accountsFromJSON(
  jsonString: string,
): SafeParseResult<Accounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Accounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Accounts' from JSON`,
  );
}
