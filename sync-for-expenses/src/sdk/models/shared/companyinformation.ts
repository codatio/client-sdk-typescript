/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AccountingAddressType,
  AccountingAddressType$inboundSchema,
  AccountingAddressType$outboundSchema,
} from "./accountingaddresstype.js";
import {
  PhoneNumberType,
  PhoneNumberType$inboundSchema,
  PhoneNumberType$outboundSchema,
} from "./phonenumbertype.js";
import {
  SupplementalData,
  SupplementalData$inboundSchema,
  SupplementalData$Outbound,
  SupplementalData$outboundSchema,
} from "./supplementaldata.js";

export type AccountingAddress = {
  /**
   * The type of the address
   */
  type: AccountingAddressType;
  /**
   * Line 1 of the customer address.
   */
  line1?: string | null | undefined;
  /**
   * Line 2 of the customer address.
   */
  line2?: string | null | undefined;
  /**
   * City of the customer address.
   */
  city?: string | null | undefined;
  /**
   * Region of the customer address.
   */
  region?: string | null | undefined;
  /**
   * Country of the customer address.
   */
  country?: string | null | undefined;
  /**
   * Postal code or zip code.
   */
  postalCode?: string | null | undefined;
};

export type Phone = {
  /**
   * A phone number.
   */
  number?: string | null | undefined;
  /**
   * The type of phone number
   */
  type: PhoneNumberType;
};

/**
 * The type of the weblink.
 */
export const CompanyInformationType = {
  Website: "Website",
  Social: "Social",
  Unknown: "Unknown",
} as const;
/**
 * The type of the weblink.
 */
export type CompanyInformationType = ClosedEnum<typeof CompanyInformationType>;

/**
 * Weblink associated with the company.
 */
export type Weblink = {
  /**
   * The type of the weblink.
   */
  type?: CompanyInformationType | undefined;
  /**
   * The full URL for the weblink.
   */
  url?: string | undefined;
};

/**
 * Company info provides standard details about a linked company such as their address, phone number, and company registration.
 *
 * @remarks
 *
 * > **Company information or companies?**
 * >
 * > Company information is standard information that is held in the accounting software about a company. `Companies` is an endpoint that lists businesses in the Codat system that have linked and shared their data sources.
 */
export type CompanyInformation = {
  /**
   * Name of the linked company.
   */
  companyName?: string | null | undefined;
  /**
   * Identifier or reference for the company in the accounting software.
   */
  accountingPlatformRef?: string | null | undefined;
  /**
   * Registered legal name of the linked company.
   */
  companyLegalName?: string | null | undefined;
  /**
   * An array of Addresses.
   */
  addresses?: Array<AccountingAddress> | null | undefined;
  /**
   * An array of phone numbers.
   */
  phoneNumbers?: Array<Phone> | null | undefined;
  /**
   * An array of weblinks.
   */
  webLinks?: Array<Weblink> | null | undefined;
  /**
   * In Codat's data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:
   *
   * @remarks
   *
   * ```
   * 2020-10-08T22:40:50Z
   * 2021-01-01T00:00:00
   * ```
   *
   * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
   *
   * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
   * - Unqualified local time: `2021-11-15T01:00:00`
   * - UTC time offsets: `2021-11-15T01:00:00-05:00`
   *
   * > Time zones
   * >
   * > Not all dates from Codat will contain information about time zones.
   * > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   */
  ledgerLockDate?: string | undefined;
  /**
   * Registration number given to the linked company by the companies authority in the country of origin. In the UK this is Companies House.
   */
  registrationNumber?: string | null | undefined;
  /**
   * Company tax number.
   */
  taxNumber?: string | null | undefined;
  /**
   * In Codat's data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:
   *
   * @remarks
   *
   * ```
   * 2020-10-08T22:40:50Z
   * 2021-01-01T00:00:00
   * ```
   *
   * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
   *
   * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
   * - Unqualified local time: `2021-11-15T01:00:00`
   * - UTC time offsets: `2021-11-15T01:00:00-05:00`
   *
   * > Time zones
   * >
   * > Not all dates from Codat will contain information about time zones.
   * > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   */
  financialYearStartDate?: string | undefined;
  /**
   * Currency set in the accounting software of the linked company. Used by the currency rate.
   */
  baseCurrency?: string | null | undefined;
  /**
   * URL addresses for the accounting source.
   *
   * @remarks
   *
   * For example, for Xero integrations two URLs are returned. These have many potential use cases, such as [deep linking](https://developer.xero.com/documentation/api-guides/deep-link-xero).
   */
  sourceUrls?: { [k: string]: string } | null | undefined;
  /**
   * In Codat's data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:
   *
   * @remarks
   *
   * ```
   * 2020-10-08T22:40:50Z
   * 2021-01-01T00:00:00
   * ```
   *
   * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
   *
   * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
   * - Unqualified local time: `2021-11-15T01:00:00`
   * - UTC time offsets: `2021-11-15T01:00:00-05:00`
   *
   * > Time zones
   * >
   * > Not all dates from Codat will contain information about time zones.
   * > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   */
  createdDate?: string | undefined;
  /**
   * Supplemental data is additional data you can include in our standard data types.
   *
   * @remarks
   *
   * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
   */
  supplementalData?: SupplementalData | undefined;
};

/** @internal */
export const AccountingAddress$inboundSchema: z.ZodType<
  AccountingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AccountingAddressType$inboundSchema,
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  region: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
});

/** @internal */
export type AccountingAddress$Outbound = {
  type: string;
  line1?: string | null | undefined;
  line2?: string | null | undefined;
  city?: string | null | undefined;
  region?: string | null | undefined;
  country?: string | null | undefined;
  postalCode?: string | null | undefined;
};

/** @internal */
export const AccountingAddress$outboundSchema: z.ZodType<
  AccountingAddress$Outbound,
  z.ZodTypeDef,
  AccountingAddress
> = z.object({
  type: AccountingAddressType$outboundSchema,
  line1: z.nullable(z.string()).optional(),
  line2: z.nullable(z.string()).optional(),
  city: z.nullable(z.string()).optional(),
  region: z.nullable(z.string()).optional(),
  country: z.nullable(z.string()).optional(),
  postalCode: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountingAddress$ {
  /** @deprecated use `AccountingAddress$inboundSchema` instead. */
  export const inboundSchema = AccountingAddress$inboundSchema;
  /** @deprecated use `AccountingAddress$outboundSchema` instead. */
  export const outboundSchema = AccountingAddress$outboundSchema;
  /** @deprecated use `AccountingAddress$Outbound` instead. */
  export type Outbound = AccountingAddress$Outbound;
}

export function accountingAddressToJSON(
  accountingAddress: AccountingAddress,
): string {
  return JSON.stringify(
    AccountingAddress$outboundSchema.parse(accountingAddress),
  );
}

export function accountingAddressFromJSON(
  jsonString: string,
): SafeParseResult<AccountingAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AccountingAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AccountingAddress' from JSON`,
  );
}

/** @internal */
export const Phone$inboundSchema: z.ZodType<Phone, z.ZodTypeDef, unknown> = z
  .object({
    number: z.nullable(z.string()).optional(),
    type: PhoneNumberType$inboundSchema,
  });

/** @internal */
export type Phone$Outbound = {
  number?: string | null | undefined;
  type: string;
};

/** @internal */
export const Phone$outboundSchema: z.ZodType<
  Phone$Outbound,
  z.ZodTypeDef,
  Phone
> = z.object({
  number: z.nullable(z.string()).optional(),
  type: PhoneNumberType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Phone$ {
  /** @deprecated use `Phone$inboundSchema` instead. */
  export const inboundSchema = Phone$inboundSchema;
  /** @deprecated use `Phone$outboundSchema` instead. */
  export const outboundSchema = Phone$outboundSchema;
  /** @deprecated use `Phone$Outbound` instead. */
  export type Outbound = Phone$Outbound;
}

export function phoneToJSON(phone: Phone): string {
  return JSON.stringify(Phone$outboundSchema.parse(phone));
}

export function phoneFromJSON(
  jsonString: string,
): SafeParseResult<Phone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Phone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Phone' from JSON`,
  );
}

/** @internal */
export const CompanyInformationType$inboundSchema: z.ZodNativeEnum<
  typeof CompanyInformationType
> = z.nativeEnum(CompanyInformationType);

/** @internal */
export const CompanyInformationType$outboundSchema: z.ZodNativeEnum<
  typeof CompanyInformationType
> = CompanyInformationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyInformationType$ {
  /** @deprecated use `CompanyInformationType$inboundSchema` instead. */
  export const inboundSchema = CompanyInformationType$inboundSchema;
  /** @deprecated use `CompanyInformationType$outboundSchema` instead. */
  export const outboundSchema = CompanyInformationType$outboundSchema;
}

/** @internal */
export const Weblink$inboundSchema: z.ZodType<Weblink, z.ZodTypeDef, unknown> =
  z.object({
    type: CompanyInformationType$inboundSchema.optional(),
    url: z.string().optional(),
  });

/** @internal */
export type Weblink$Outbound = {
  type?: string | undefined;
  url?: string | undefined;
};

/** @internal */
export const Weblink$outboundSchema: z.ZodType<
  Weblink$Outbound,
  z.ZodTypeDef,
  Weblink
> = z.object({
  type: CompanyInformationType$outboundSchema.optional(),
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Weblink$ {
  /** @deprecated use `Weblink$inboundSchema` instead. */
  export const inboundSchema = Weblink$inboundSchema;
  /** @deprecated use `Weblink$outboundSchema` instead. */
  export const outboundSchema = Weblink$outboundSchema;
  /** @deprecated use `Weblink$Outbound` instead. */
  export type Outbound = Weblink$Outbound;
}

export function weblinkToJSON(weblink: Weblink): string {
  return JSON.stringify(Weblink$outboundSchema.parse(weblink));
}

export function weblinkFromJSON(
  jsonString: string,
): SafeParseResult<Weblink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Weblink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Weblink' from JSON`,
  );
}

/** @internal */
export const CompanyInformation$inboundSchema: z.ZodType<
  CompanyInformation,
  z.ZodTypeDef,
  unknown
> = z.object({
  companyName: z.nullable(z.string()).optional(),
  accountingPlatformRef: z.nullable(z.string()).optional(),
  companyLegalName: z.nullable(z.string()).optional(),
  addresses: z.nullable(z.array(z.lazy(() => AccountingAddress$inboundSchema)))
    .optional(),
  phoneNumbers: z.nullable(z.array(z.lazy(() => Phone$inboundSchema)))
    .optional(),
  webLinks: z.nullable(z.array(z.lazy(() => Weblink$inboundSchema))).optional(),
  ledgerLockDate: z.string().optional(),
  registrationNumber: z.nullable(z.string()).optional(),
  taxNumber: z.nullable(z.string()).optional(),
  financialYearStartDate: z.string().optional(),
  baseCurrency: z.nullable(z.string()).optional(),
  sourceUrls: z.nullable(z.record(z.string())).optional(),
  createdDate: z.string().optional(),
  supplementalData: SupplementalData$inboundSchema.optional(),
});

/** @internal */
export type CompanyInformation$Outbound = {
  companyName?: string | null | undefined;
  accountingPlatformRef?: string | null | undefined;
  companyLegalName?: string | null | undefined;
  addresses?: Array<AccountingAddress$Outbound> | null | undefined;
  phoneNumbers?: Array<Phone$Outbound> | null | undefined;
  webLinks?: Array<Weblink$Outbound> | null | undefined;
  ledgerLockDate?: string | undefined;
  registrationNumber?: string | null | undefined;
  taxNumber?: string | null | undefined;
  financialYearStartDate?: string | undefined;
  baseCurrency?: string | null | undefined;
  sourceUrls?: { [k: string]: string } | null | undefined;
  createdDate?: string | undefined;
  supplementalData?: SupplementalData$Outbound | undefined;
};

/** @internal */
export const CompanyInformation$outboundSchema: z.ZodType<
  CompanyInformation$Outbound,
  z.ZodTypeDef,
  CompanyInformation
> = z.object({
  companyName: z.nullable(z.string()).optional(),
  accountingPlatformRef: z.nullable(z.string()).optional(),
  companyLegalName: z.nullable(z.string()).optional(),
  addresses: z.nullable(z.array(z.lazy(() => AccountingAddress$outboundSchema)))
    .optional(),
  phoneNumbers: z.nullable(z.array(z.lazy(() => Phone$outboundSchema)))
    .optional(),
  webLinks: z.nullable(z.array(z.lazy(() => Weblink$outboundSchema)))
    .optional(),
  ledgerLockDate: z.string().optional(),
  registrationNumber: z.nullable(z.string()).optional(),
  taxNumber: z.nullable(z.string()).optional(),
  financialYearStartDate: z.string().optional(),
  baseCurrency: z.nullable(z.string()).optional(),
  sourceUrls: z.nullable(z.record(z.string())).optional(),
  createdDate: z.string().optional(),
  supplementalData: SupplementalData$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyInformation$ {
  /** @deprecated use `CompanyInformation$inboundSchema` instead. */
  export const inboundSchema = CompanyInformation$inboundSchema;
  /** @deprecated use `CompanyInformation$outboundSchema` instead. */
  export const outboundSchema = CompanyInformation$outboundSchema;
  /** @deprecated use `CompanyInformation$Outbound` instead. */
  export type Outbound = CompanyInformation$Outbound;
}

export function companyInformationToJSON(
  companyInformation: CompanyInformation,
): string {
  return JSON.stringify(
    CompanyInformation$outboundSchema.parse(companyInformation),
  );
}

export function companyInformationFromJSON(
  jsonString: string,
): SafeParseResult<CompanyInformation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyInformation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyInformation' from JSON`,
  );
}
