/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { Decimal as Decimal$ } from "../../types/decimal.js";
import { ClosedEnum } from "../../types/enums.js";
import * as z from "zod";

/**
 * Type of transaction for the bank statement line.
 */
export const BankTransactionType = {
    Unknown: "Unknown",
    Credit: "Credit",
    Debit: "Debit",
    Int: "Int",
    Div: "Div",
    Fee: "Fee",
    SerChg: "SerChg",
    Dep: "Dep",
    Atm: "Atm",
    Pos: "Pos",
    Xfer: "Xfer",
    Check: "Check",
    Payment: "Payment",
    Cash: "Cash",
    DirectDep: "DirectDep",
    DirectDebit: "DirectDebit",
    RepeatPmt: "RepeatPmt",
    Other: "Other",
} as const;
/**
 * Type of transaction for the bank statement line.
 */
export type BankTransactionType = ClosedEnum<typeof BankTransactionType>;

export type BankTransactions = {
    /**
     * Identifier for the bank account transaction, unique for the company in the accounting platform.
     */
    id: string;
    /**
     * In Codat's data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:
     *
     * @remarks
     *
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     *
     *
     *
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     *
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     *
     * > Time zones
     * >
     * > Not all dates from Codat will contain information about time zones.
     * > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    date: string;
    /**
     * Description of the bank transaction.
     */
    description?: string | null | undefined;
    /**
     * The giving or receiving party such as a person or organization.
     */
    counterparty?: string | null | undefined;
    /**
     * An optional reference to the bank transaction.
     */
    reference?: string | null | undefined;
    /**
     * `True` if the bank transaction has been [reconciled](https://www.xero.com/uk/guides/what-is-bank-reconciliation/) in the accounting platform.
     */
    reconciled?: boolean | null | undefined;
    /**
     * The amount transacted in the bank transaction.
     */
    amount: Decimal$ | number;
    /**
     * The remaining balance in the account with ID `accountId`.
     */
    balance?: Decimal$ | number | undefined;
    /**
     * Type of transaction for the bank statement line.
     */
    transactionType?: BankTransactionType | null | undefined;
};

/** @internal */
export const BankTransactionType$inboundSchema: z.ZodNativeEnum<typeof BankTransactionType> =
    z.nativeEnum(BankTransactionType);

/** @internal */
export const BankTransactionType$outboundSchema: z.ZodNativeEnum<typeof BankTransactionType> =
    BankTransactionType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BankTransactionType$ {
    /** @deprecated use `BankTransactionType$inboundSchema` instead. */
    export const inboundSchema = BankTransactionType$inboundSchema;
    /** @deprecated use `BankTransactionType$outboundSchema` instead. */
    export const outboundSchema = BankTransactionType$outboundSchema;
}

/** @internal */
export const BankTransactions$inboundSchema: z.ZodType<BankTransactions, z.ZodTypeDef, unknown> =
    z.object({
        id: z.string(),
        date: z.string(),
        description: z.nullable(z.string()).optional(),
        counterparty: z.nullable(z.string()).optional(),
        reference: z.nullable(z.string()).optional(),
        reconciled: z.nullable(z.boolean()).optional(),
        amount: z.number().transform((v) => new Decimal$(v)),
        balance: z
            .number()
            .transform((v) => new Decimal$(v))
            .optional(),
        transactionType: z.nullable(BankTransactionType$inboundSchema).optional(),
    });

/** @internal */
export type BankTransactions$Outbound = {
    id: string;
    date: string;
    description?: string | null | undefined;
    counterparty?: string | null | undefined;
    reference?: string | null | undefined;
    reconciled?: boolean | null | undefined;
    amount: number;
    balance?: number | undefined;
    transactionType?: string | null | undefined;
};

/** @internal */
export const BankTransactions$outboundSchema: z.ZodType<
    BankTransactions$Outbound,
    z.ZodTypeDef,
    BankTransactions
> = z.object({
    id: z.string(),
    date: z.string(),
    description: z.nullable(z.string()).optional(),
    counterparty: z.nullable(z.string()).optional(),
    reference: z.nullable(z.string()).optional(),
    reconciled: z.nullable(z.boolean()).optional(),
    amount: z
        .union([z.instanceof(Decimal$), z.number()])
        .transform((v) => (typeof v === "number" ? v : v.toNumber())),
    balance: z
        .union([z.instanceof(Decimal$), z.number()])
        .transform((v) => (typeof v === "number" ? v : v.toNumber()))
        .optional(),
    transactionType: z.nullable(BankTransactionType$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BankTransactions$ {
    /** @deprecated use `BankTransactions$inboundSchema` instead. */
    export const inboundSchema = BankTransactions$inboundSchema;
    /** @deprecated use `BankTransactions$outboundSchema` instead. */
    export const outboundSchema = BankTransactions$outboundSchema;
    /** @deprecated use `BankTransactions$Outbound` instead. */
    export type Outbound = BankTransactions$Outbound;
}
